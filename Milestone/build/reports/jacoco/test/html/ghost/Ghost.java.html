<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Ghost.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Milestone</a> &gt; <a href="index.source.html" class="el_package">ghost</a> &gt; <span class="el_source">Ghost.java</span></div><h1>Ghost.java</h1><pre class="source lang-java linenums">package ghost;

import processing.core.PImage;

import java.util.ArrayList;
import java.util.Collections;

import javax.management.RuntimeErrorException;

public abstract class Ghost extends Movable {
    // Scatter/Chase mode timer
    private Mode mode;
    private int frameCount;
    private int cycleIndex;
    private long cycleLength;
    private long frightenedCount;
    private long frightenedLength;
    private Mode savedMode;
    private boolean alive;

    // Corner target coordinate
    private final int[] corner;

    public Ghost(int x, int y, PImage sprite, GameManager gm, int gridX, int gridY, int cornerX, int cornerY) {
<span class="fc" id="L25">        super(x, y, sprite, gm, gridX, gridY);</span>
<span class="fc" id="L26">        this.alive = true;</span>

        // Modes
<span class="fc" id="L29">        this.mode = Mode.Scatter;</span>
<span class="fc" id="L30">        this.frameCount = 0;</span>
<span class="fc" id="L31">        this.cycleIndex = 0;</span>
<span class="fc" id="L32">        this.cycleLength = getGm().modeLengths.get(cycleIndex) * 60;</span>
<span class="fc" id="L33">        this.frameCount = 0;</span>
<span class="fc" id="L34">        this.frightenedLength = getGm().frightenedLength * 60;</span>

        // Collision
<span class="fc" id="L37">        setBorderTop(getY() + 2);</span>
<span class="fc" id="L38">        setBorderBot(getY() + 23);</span>
<span class="fc" id="L39">        setBorderLeft(getX() + 2);</span>
<span class="fc" id="L40">        setBorderRight(getX() + 25);</span>

        // Set corner
<span class="fc" id="L43">        this.corner = new int[2];</span>
<span class="fc" id="L44">        this.corner[0] = cornerX;</span>
<span class="fc" id="L45">        this.corner[1] = cornerY;</span>

<span class="fc" id="L47">    }</span>

<span class="fc" id="L49">public enum Mode {</span>
<span class="fc" id="L50">    Scatter,</span>
<span class="fc" id="L51">    Chase,</span>
<span class="fc" id="L52">    Frightened</span>
}
    public void draw() {
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">        if (alive) {</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">            if (this.mode != Mode.Frightened) { </span>
<span class="nc" id="L57">                getGm().app.image(getSprite(), getX() - 5, getY() - 6);</span>
            } else { //If frightened, draw frightened image
<span class="nc" id="L59">                getGm().app.image(getGm().app.frightenedImage, getX() - 5, getY() - 6);</span>
            }
        }
<span class="fc" id="L62">    }</span>

    public void tick() {
<span class="fc" id="L65">        checkIfFrightened();</span>
<span class="fc" id="L66">        selectMode();</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">        if (alive) {</span>
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">            if (getGm().debug) {</span>
<span class="nc" id="L69">                drawTargetLine();</span>
            }
<span class="fc bfc" id="L71" title="All 2 branches covered.">            if (canChangeDirection()) {</span>
<span class="fc" id="L72">                selectDirection();</span>
            }
<span class="fc" id="L74">            move();</span>
<span class="fc" id="L75">            setCollisionBorders();</span>
        }
<span class="fc" id="L77">    }</span>
    
    public void setCollisionBorders() {
        // Set collision borders
<span class="fc" id="L81">        setBorderTop(getY() + 2);</span>
<span class="fc" id="L82">        setBorderBot(getY() + 23);</span>
<span class="fc" id="L83">        setBorderLeft(getX() + 2);</span>
<span class="fc" id="L84">        setBorderRight(getX() + 25);</span>
<span class="fc" id="L85">    }</span>
    
    //Draws lines to target location
    public void drawTargetLine() {
<span class="fc" id="L89">        int[] vector = null;</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        if (this.mode == Mode.Chase) {</span>
<span class="nc" id="L91">            vector = generateVectors(getGm().player.getX(), getGm().player.getY());</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        } else if (this.mode == Mode.Scatter) {</span>
<span class="fc" id="L93">            vector = generateVectors(this.corner[0], this.corner[1]);</span>
        } 
<span class="pc bpc" id="L95" title="1 of 4 branches missed.">        if (this.mode != Mode.Frightened &amp;&amp; getGm().app.g != null) {</span>
<span class="nc" id="L96">            getGm().app.g.line(this.getX(), this.getY(), vector[0] + this.getX(), vector[1] + this.getY());</span>
<span class="nc" id="L97">            getGm().app.g.stroke(126);</span>
        }
<span class="fc" id="L99">    }</span>
    
    //Sets the direction of travel based on generation of next move
    public void selectDirection() {
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (this.mode == Mode.Frightened) {</span>
<span class="fc" id="L104">            setDirection(generateNextMove(0, 0));</span>
<span class="fc" id="L105">            return;</span>
        }
        //If ghost is still, initialise travel direction
<span class="fc bfc" id="L108" title="All 2 branches covered.">        if (getDirection() == Direction.Still) {</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">            if (this.mode == Mode.Chase) {</span>
<span class="fc" id="L110">                setDirection(generateNextMove(getGm().player.getGridX() * 16, getGm().player.getGridY() * 16));</span>
            } else {
<span class="fc" id="L112">                setDirection(generateNextMove(this.corner[0], this.corner[1]));</span>
            }
        }
        //Check if location appropriate for change of direction (intersection)
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (canChangeDirection()) {</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">            if (this.mode.equals(Mode.Scatter)) {</span>
<span class="fc" id="L118">                setDirection(generateNextMove(this.corner[0], this.corner[1]));</span>
            } else {
<span class="fc" id="L120">                setDirection(generateNextMove(getGm().player.getGridX() * 16, getGm().player.getGridY() * 16));</span>
            }
        }
<span class="fc" id="L123">    }</span>
    
    //Selects mode based on timer and mode lengths configuration
    public void selectMode() {
<span class="fc bfc" id="L127" title="All 2 branches covered.">        if (this.mode != Mode.Frightened) {</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">            if (this.frameCount &lt; this.cycleLength) {</span>
<span class="fc" id="L129">                this.frameCount++;</span>
            } else {
<span class="fc" id="L131">                this.frameCount = 0;</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">                if (this.cycleIndex &lt; getGm().modeLengths.size() - 1) {</span>
<span class="fc" id="L133">                    this.cycleIndex++;</span>
<span class="fc" id="L134">                    this.cycleLength = getGm().modeLengths.get(this.cycleIndex) * 60;</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">                    if (this.cycleIndex % 2 == 1) {</span>
<span class="fc" id="L136">                        this.mode = Mode.Chase;</span>
                    } else {
<span class="fc" id="L138">                        this.mode = Mode.Scatter;</span>
                    }
                } else {
<span class="fc" id="L141">                    this.cycleIndex = 0;</span>
<span class="fc" id="L142">                    this.cycleLength = getGm().modeLengths.get(this.cycleIndex) * 60;</span>
<span class="fc" id="L143">                    this.mode = Mode.Chase;</span>
                }
            }
        }
<span class="fc" id="L147">    }</span>
    
    //Generates next move given a list of preferences for direction of travel
    public Direction generateNextMove(int targetx, int targety) {
<span class="fc" id="L151">        int[] vector = generateVectors(targetx, targety);</span>
<span class="fc" id="L152">        Direction preferredMove = null;</span>
<span class="fc" id="L153">        ArrayList&lt;Direction&gt; preferenceList = generatePreferences(getDirection(), vector);</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        for (Direction preference : preferenceList) {</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">            if (canGoDirection(preference)) {</span>
<span class="fc" id="L156">                preferredMove = preference;</span>
<span class="fc" id="L157">                break;// Go through preferences in order, execute first one which is valid</span>
            }
<span class="fc" id="L159">        }</span>
<span class="fc" id="L160">        return preferredMove; //Default use last preference</span>
    }
    
    //Check that ghost is at an intersection, and completely within a grid, so it can change direction
    public boolean canChangeDirection() {
<span class="fc bfc" id="L165" title="All 4 branches covered.">        if (this.getX() % 16 == 0 &amp;&amp; this.getY() % 16 == 0) {</span>
<span class="fc bfc" id="L166" title="All 4 branches covered.">            if (getDirection() == Direction.Up || getDirection() == Direction.Down) {</span>
<span class="pc bpc" id="L167" title="2 of 8 branches missed.">                if (!this.wallOnLeft() || !this.wallOnRight() || collideWallAbove() || collideWallBelow()) {</span>
<span class="fc" id="L168">                    return true;</span>
                } else {
<span class="fc" id="L170">                    return false;</span>
                }
<span class="fc bfc" id="L172" title="All 4 branches covered.">            } else if (getDirection() == Direction.Left || getDirection() == Direction.Right) {</span>
<span class="pc bpc" id="L173" title="2 of 8 branches missed.">                if (!this.wallBelow() || !this.wallAbove() || collideWallOnLeft() || collideWallOnRight()) {</span>
<span class="fc" id="L174">                    return true;</span>
                } else {
<span class="fc" id="L176">                    return false;</span>
                }
            } else {
<span class="fc" id="L179">                return true;</span>
            }
        } else {
<span class="fc" id="L182">            return false;</span>
        }
    }
    
    public boolean canGoDirection(Direction direction) {
        // Determine if can go in a particular direction based on wall locations
<span class="fc bfc" id="L188" title="All 2 branches covered.">        if (direction == Direction.Right) {</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">            if (wallOnRight()) {</span>
<span class="fc" id="L190">                return false;</span>
            }
<span class="fc" id="L192">            return true;</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        } else if (direction == Direction.Left) {</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">            if (wallOnLeft()) {</span>
<span class="fc" id="L195">                return false;</span>
            } else {
<span class="fc" id="L197">                return true;</span>
            }
<span class="fc bfc" id="L199" title="All 2 branches covered.">        } else if (direction == Direction.Up) {</span>
            //throw new RuntimeException();
<span class="fc bfc" id="L201" title="All 2 branches covered.">            if (wallAbove()) {</span>
<span class="fc" id="L202">                return false;</span>
            } else {
<span class="fc" id="L204">                return true;</span>
            }
        } else {
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (wallBelow()) {</span>
<span class="fc" id="L208">                return false;</span>
            } else {
<span class="fc" id="L210">                return true;</span>
            }
        } 
    }
    
    public abstract int[] generateVectors(int targetx, int targety);
    
    
    //Generate list of moves based on intended vector in preferred order
    public ArrayList&lt;Direction&gt; generatePreferences(Direction direction, int[] vector) {
<span class="fc" id="L220">        ArrayList&lt;Direction&gt; preferenceList = new ArrayList&lt;Direction&gt;();</span>
<span class="fc" id="L221">        int vectorx = vector[0];</span>
<span class="fc" id="L222">        int vectory = vector[1];</span>

<span class="fc bfc" id="L224" title="All 4 branches covered.">        if (vectorx &gt;= 0 &amp;&amp; vectory &gt;= 0) {</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">            if (vectorx &gt;= vectory) { // want to go right and down</span>
<span class="fc" id="L226">                preferenceList.add(Direction.Right);</span>
<span class="fc" id="L227">                preferenceList.add(Direction.Down);</span>
<span class="fc" id="L228">                preferenceList.add(Direction.Up);</span>
<span class="fc" id="L229">                preferenceList.add(Direction.Left);</span>
            } else { // want to go down and right
<span class="fc" id="L231">                preferenceList.add(Direction.Down);</span>
<span class="fc" id="L232">                preferenceList.add(Direction.Right);</span>
<span class="fc" id="L233">                preferenceList.add(Direction.Left);</span>
<span class="fc" id="L234">                preferenceList.add(Direction.Up);</span>
            }
<span class="pc bpc" id="L236" title="1 of 4 branches missed.">        } else if (vectorx &gt;= 0 &amp;&amp; vectory &lt;= 0) {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            if (vectorx &gt;= -vectory) { // want to go right and up</span>
<span class="fc" id="L238">                preferenceList.add(Direction.Right);</span>
<span class="fc" id="L239">                preferenceList.add(Direction.Up);</span>
<span class="fc" id="L240">                preferenceList.add(Direction.Down);</span>
<span class="fc" id="L241">                preferenceList.add(Direction.Left);</span>
            } else { // want to go up and right
<span class="fc" id="L243">                preferenceList.add(Direction.Up);</span>
<span class="fc" id="L244">                preferenceList.add(Direction.Right);</span>
<span class="fc" id="L245">                preferenceList.add(Direction.Left);</span>
<span class="fc" id="L246">                preferenceList.add(Direction.Down);</span>
            }
<span class="pc bpc" id="L248" title="1 of 4 branches missed.">        } else if (vectorx &lt;= 0 &amp;&amp; vectory &lt;= 0) {</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">            if (-vectorx &gt;= -vectory) { // want to go left and up</span>
<span class="fc" id="L250">                preferenceList.add(Direction.Left);</span>
<span class="fc" id="L251">                preferenceList.add(Direction.Up);</span>
<span class="fc" id="L252">                preferenceList.add(Direction.Down);</span>
<span class="fc" id="L253">                preferenceList.add(Direction.Right);</span>
            } else { // want to go up and left
<span class="fc" id="L255">                preferenceList.add(Direction.Up);</span>
<span class="fc" id="L256">                preferenceList.add(Direction.Left);</span>
<span class="fc" id="L257">                preferenceList.add(Direction.Right);</span>
<span class="fc" id="L258">                preferenceList.add(Direction.Down);</span>
            }
        } else {
<span class="fc bfc" id="L261" title="All 2 branches covered.">            if (-vectorx &gt;= vectory) { // want to go left and down</span>
<span class="fc" id="L262">                preferenceList.add(Direction.Left);</span>
<span class="fc" id="L263">                preferenceList.add(Direction.Down);</span>
<span class="fc" id="L264">                preferenceList.add(Direction.Up);</span>
<span class="fc" id="L265">                preferenceList.add(Direction.Right);</span>
            } else { // want to go down and left
<span class="fc" id="L267">                preferenceList.add(Direction.Down);</span>
<span class="fc" id="L268">                preferenceList.add(Direction.Left);</span>
<span class="fc" id="L269">                preferenceList.add(Direction.Right);</span>
<span class="fc" id="L270">                preferenceList.add(Direction.Up);</span>
            }
        }

<span class="fc bfc" id="L274" title="All 2 branches covered.">        if (this.mode.equals(Mode.Frightened)) {</span>
            // Randomise preference list if in frightened mode
<span class="fc" id="L276">            Collections.shuffle(preferenceList);</span>
        } 

        // change opposite direction of movement as last preference
<span class="fc bfc" id="L280" title="All 2 branches covered.">        if (direction == Direction.Left) {</span>
<span class="fc" id="L281">            preferenceList.remove(Direction.Right);</span>
<span class="fc" id="L282">            preferenceList.add(Direction.Right);</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">        } else if (direction == Direction.Right) {</span>
<span class="fc" id="L284">            preferenceList.remove(Direction.Left);</span>
<span class="fc" id="L285">            preferenceList.add(Direction.Left);</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">        } else if (direction == Direction.Up) {</span>
<span class="fc" id="L287">            preferenceList.remove(Direction.Down);</span>
<span class="fc" id="L288">            preferenceList.add(Direction.Down);</span>
        } else {
<span class="fc" id="L290">            preferenceList.remove(Direction.Up);</span>
<span class="fc" id="L291">            preferenceList.add(Direction.Up);</span>
        }
        
<span class="fc" id="L294">        return preferenceList;</span>
    }
    //Timer for frightened mode
    public void checkIfFrightened() {
<span class="fc bfc" id="L298" title="All 2 branches covered.">        if (this.mode == Mode.Frightened) {</span>
<span class="fc" id="L299">            this.frightenedCount++;</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">            if (this.frightenedCount == frightenedLength) {</span>
<span class="fc" id="L301">                this.mode = this.savedMode;</span>
<span class="fc" id="L302">                this.frightenedCount = 0;</span>
            }
        }
<span class="fc" id="L305">    }</span>

    //Restart ghost from start of game
    public void restartGhost() {
<span class="fc" id="L309">        setAlive(true);</span>

        // Restart coordinates
<span class="fc" id="L312">        setX(getStartX());</span>
<span class="fc" id="L313">        setY(getStartY());</span>
<span class="fc" id="L314">        setGridX((int) Math.floor(getX() / 16));</span>
<span class="fc" id="L315">        setGridY((int) Math.floor(getY() / 16));</span>
<span class="fc" id="L316">        setCollisionBorders();</span>

        // Restart direction
<span class="fc" id="L319">        setDirection(Direction.Still);</span>
<span class="fc" id="L320">        setXVel(0);</span>
<span class="fc" id="L321">        setYVel(0);</span>

        // Restart modes
<span class="fc" id="L324">        setMode(Mode.Scatter);</span>
<span class="fc" id="L325">        frightenedCount = 0;</span>
<span class="fc" id="L326">        this.frameCount = 0;</span>
<span class="fc" id="L327">        this.cycleIndex = 0;</span>
<span class="fc" id="L328">        this.cycleLength = getGm().modeLengths.get(cycleIndex) * 60;</span>
<span class="fc" id="L329">        this.frameCount = 0;</span>
<span class="fc" id="L330">        this.frightenedLength = getGm().frightenedLength * 60;</span>

<span class="fc" id="L332">    }</span>
    
    //Getters and setters
    public Mode getMode() {
<span class="fc" id="L336">        return this.mode;</span>
    }

    public void setMode(Mode mode) {
<span class="fc" id="L340">        this.mode = mode;</span>
<span class="fc" id="L341">    }</span>

    public Mode getSavedMode() {
<span class="fc" id="L344">        return this.savedMode;</span>
    }

    public void setSavedMode(Mode savedMode) {
<span class="fc" id="L348">        this.savedMode = savedMode;</span>
<span class="fc" id="L349">    }</span>

    public int[] getCorner() {
<span class="fc" id="L352">        return this.corner;</span>
    }

    public boolean isAlive() {
<span class="fc" id="L356">        return this.alive;</span>
    }

    public void setAlive(boolean alive) {
<span class="fc" id="L360">        this.alive = alive;</span>
<span class="fc" id="L361">    }</span>

    public void setFrightenedCount(long frightenedCount) {
<span class="fc" id="L364">        this.frightenedCount = frightenedCount;</span>
<span class="fc" id="L365">    }</span>
    
    public void setCycleLength(long cycleLength) {
<span class="fc" id="L368">        this.cycleLength = cycleLength;</span>
<span class="fc" id="L369">    }</span>

    public void setFrameCount(int frameCount) {
<span class="fc" id="L372">        this.frameCount = frameCount;</span>
<span class="fc" id="L373">    }</span>

    public int getFrameCount() {
<span class="fc" id="L376">        return this.frameCount;</span>
    }

    public void setCycleIndex(int index) {
<span class="fc" id="L380">        this.cycleIndex = index;</span>
<span class="fc" id="L381">    }</span>

    public int getCycleIndex() {
<span class="fc" id="L384">        return this.cycleIndex;</span>
    }
    
    public long getFrightenedCount() {
<span class="fc" id="L388">        return this.frightenedCount;</span>
    }

    public void setFrightenedLength(long length) {
<span class="fc" id="L392">        this.frightenedLength = length;</span>
<span class="fc" id="L393">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>